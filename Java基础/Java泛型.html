<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/306387 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="626"/>

<div>
<span><div><font style="font-size: 36pt;"><span style="font-size: 36pt; font-weight: bold;">Java泛型</span></font></div><div><span style="font-weight: bold; font-size: 16pt;">一、基础知识</span></div><div><br/></div><div><span style="font-weight: bold;">1、类型擦除</span></div><div><br/></div><div>     <span style="color: rgb(26, 173, 224);">类型擦除</span>指的是<span style="color: rgb(255, 0, 0);">通过类型参数合并， 将泛型类型实例关联到同一份字节码上。</span> 编译器只为泛型类型生成一份字节码， 并将其实例关联到这份字节码上， 因此泛型类型中的静态变量是所有实例共享的。</div><div><br/></div><div>（1） <span style="color: rgb(77, 206, 29);">一个static 方法， 无法访问泛型类的类型参数，</span> 因为类还没有实例化， 所以， 若static方法需要使用泛型能力， 必须使其成为泛型方法，（泛型参数稍后会介绍），即<span style="color: rgb(77, 206, 29);">没有成为泛型方法的静态方法不能访问类型参数。</span></div><div>（2） <span style="color: rgb(77, 206, 29);">泛型类的静态上下文中类型变量无效</span>，即静态变量不能引用类型变量。</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="color: rgb(255, 0, 0); font-family: Monaco; font-size: 9pt;">错误代码片段</span></div><div>01.public class Singleton&lt;T&gt;{  </div><div>02.    private static T singleInstance;//错误，违反第二条  </div><div>03.    public static T getSingleInstance() // 错误，违反第一条  </div><div>04.    {  </div><div>05.        if(singleInstance == null)  </div><div>06.               Return singleInstance;  </div><div>07.    }  </div><div>08.}  </div></div><div><br/></div><div>（3） <span style="color: rgb(77, 206, 29);">在使用泛型时， 任何具体的类型都被擦除， 唯一知道的是你在使用一个对象</span>。</div><div>        比如：List&lt;String&gt;和List&lt;Integer&gt;在运行事实上是相同的类型。 他们都被擦除成他们的原生类型，即List。 因为编译的时候会有类型擦除， 所以不能通过同一个泛型类的实例来区分方法， 如下面的例子编译时会出错， <span style="text-decoration: underline; font-style: italic;">因为类型擦除后， 两个方法都是List 类型的参数， 因此并不能根据泛型类的类型来区分方法。</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="color: rgb(255, 0, 0);">错误代码片段</font></div><div>02. public class Erasure{  </div><div>03.   public void test(List&lt;String&gt; ls){  </div><div>04.       System.out.println(&quot;Sting&quot;);  </div><div>05.   }  </div><div>06.   public void test(List&lt;Integer&gt; li){  </div><div>07.       System.out.println(&quot;Integer&quot;);  </div><div>08.   }  </div><div>09. }</div></div><div><br/></div><div>（4） <span style="color: rgb(77, 206, 29);">所有泛型类的实例都共享同一个运行时类， 类型参数信息会在</span><span style="color: rgb(255, 0, 0);">编译</span><span style="color: rgb(77, 206, 29);">时被擦除。</span> 因此考</div><div>虑如下代码， 虽然 ArrayList&lt;String&gt;和 ArrayList&lt;Integer&gt;类型参数不同， 但是他们都共享</div><div>ArrayList 类， 所以结果会是 true。</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="color: rgb(255, 0, 0); font-family: Monaco; font-size: 9pt;">正确代码片段</span></div><div>01.List&lt;String&gt; l1 = new ArrayList&lt;String&gt;();  </div><div>02.List&lt;Integer&gt; l2 = new ArrayList&lt;Integer&gt;();  </div><div>03.System.out.println(l1.getClass() == l2.getClass()); //True</div></div><div><br/></div><div>（5） <span style="color: rgb(77, 206, 29);">不能对确切的泛型类型使用instanceOf 操作。</span>因为instanceof会在运行时检测对象的类型，而泛型在运行时已经被擦除了，所以所有的List都是一样的，set也都是一样的。如下面的操作是非法的， 编译时会出错。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="color: rgb(255, 0, 0); font-family: Monaco; font-size: 9pt;">错误代码片段</span></div><div>01.Collection cs = new ArrayList&lt;String&gt;();  </div><div>02.if (cs instanceof Collection&lt;String&gt;){…}<font color="#FF0000">// compile error.如果改成instanceof Collection&lt;?&gt;则不会出错。</font></div></div><div><br/></div><div>（6） <span style="color: rgb(77, 206, 29);">不能用基本类型实例化类型参数，</span> 因此吗， 没有 Pair&lt;double&gt;,只有Pair&lt;Double&gt;,原</div><div>因是类型擦除， 擦除后， Pair类含有Object类型的域， 而Object不能存储doble 值。</div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">2、泛型和子类型</span></div><div><br/></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>01.List&lt;Apple&gt; apples = new ArrayList&lt;Apple&gt;(); <font color="#4DCE1D">//right  </font></div><div>02.List&lt;Fruit&gt; fruits = apples; <font color="#FF0000">//error</font></div></div><div><br/></div><div>我们假定第2行代码没有问题， 那么我们可以使用语句fruits.add(new Strawberry())</div><div>（  Strawberry  为 Fruit的子类） 在fruits中加入草莓了， 但是这样的话， 一个List中装入了</div><div>各种不同类型的子类水果， 这显然是不可以的， 因为我们在取出 List中的水果对象时， 就</div><div>分不清楚到底该转型为苹果还是草莓了。</div><div><br/></div><div>通常来说，如果 Foo是Bar的子类型，G是一种带泛型的类型，则G&lt;Foo&gt;不是G&lt;Bar&gt;</div><div>的子类型。</div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">3、通配符</span></div><div><br/></div><div>(1)<span style="color: rgb(77, 206, 29);">&lt;?&gt;非限定通配符</span></div><div><br/></div><div>//使用<span style="color: rgb(77, 206, 29);">通配符？</span> ， 表示可以接收任何元素类型的集合作为参数  </div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>02. public void printCollection(Collection&lt;?&gt; c) {  </div><div>03.    for (Object e:c) {  </div><div>04.         System.out.println(e);  </div><div>05.    }  </div><div>06. }</div></div><div><br/></div><div>这里使用了通配符？ 指定可以使用任何类型的集合作为参数。 读取的元素使用了 Object 类型来表示， 这是安全的， 因为<span style="text-decoration: underline; font-style: italic;">所有的类都是 Object 的子类</span>。 这里就又出现了另外一个问题，如下代码所示， 如果试图往使用通配符？ 的集合中加入对象， 就会在编译时出现错误。 需要注意的是， 这里不管加入什么类型的对象都会出错。这是因为<span style="color: rgb(77, 206, 29);">通配符？ 表示该集合存储的元素类型未知， 可以是任何类型。</span> <span style="color: rgb(65, 173, 28);">往集合中加入元素需要是一个未知元素类型的子类型</span><span style="color: rgb(65, 173, 28);">，</span> 正因为该集合存储的元素类型未知， 所以我们没法向该集合中添加任何元素。唯一的例外是null，因为null是所有类型的子类型， 所以尽管元素类型不知道， 但是null一定是它的子类型。</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="color: rgb(255, 0, 0); font-family: Monaco; font-size: 9pt;">错误代码片段</span></div><div>01.Collection&lt;?&gt; c=new ArrayList&lt;String&gt;();  </div><div>02.c.add(new Object()); <font color="#FF0000">//compile time error， 不管加入什么对象都出错， 除了 null 外。  </font></div><div>03.c.add(null); //OK&lt;/span&gt;  </div></div><div><br/></div><div>(2)<span style="color: rgb(77, 206, 29);">限制性通配符：</span></div><div><br/></div><div><span style="color: rgb(77, 206, 29);">&lt;? extends A&gt;</span>从一个数据类型里获取数据</div><div><br/></div><div><span style="color: rgb(77, 206, 29);">&lt;? super B&gt;</span>把对象写入一个数据结构里</div><div><br/></div><div>假定有一个画图的应用， 可以画各种形状的图形， 如矩形和圆形等。 为了在程序里面表示，</div><div>定义如下的类层次：</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>01. public abstract class Shape {  </div><div>02.    public abstract void draw(Canvas c);  </div><div>03. }  </div><div>04. public class Circle extends Shape {  </div><div>05.    private int x,y,radius;  </div><div>06.    public void draw(Canvas c) { ... }  </div><div>07. }  </div><div>08. public class Rectangle extends Shape  </div><div>09.    private int x,y,width,height;  </div><div>10.    public void draw(Canvas c) { ... }  </div><div>11. }</div></div><div><br/></div><div>如果我们希望在<span style="color: rgb(77, 206, 29);">List&lt;？exends Shape&gt; shapes</span> 中加入一个矩形对象， 如下所示：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>shapes.add(0, new Rectangle()); <font color="#FF0000">//compile-time error</font></div></div><div><br/></div><div>那么这时会出现一个编译时错误， 原因在于： 我们只知道 shapes 中的元素时 Shape类型的子类型， 具体是什么子类型我们并不清楚， 所以我们不能往shapes中加入任何类型的对象。不过我们在取出其中对象时， 可以使用 Shape 类型来取值， 因为虽然我们不知道列表中的元素类型具体是什么类型， 但是我们肯定的是它一定是Shape类的子类型。 所以可以用Shape接收取出的对象， 但不能向其中添加对象。</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>01.List&lt;Shape&gt; shapes = new ArrayList&lt;Shape&gt;();  </div><div>02.List&lt;? super Cicle&gt; cicleSupers = shapes;  </div><div>03.cicleSupers.add(new Cicle()); <font color="#4DCE1D">//OK, subclass of Cicle also OK  </font></div><div>04.cicleSupers.add(new Shape()); <font color="#FF0000">//ERROR </font></div></div><div><br/></div><div>这表示cicleSupers 列表存储的元素为 Circle 的超类， 因此我们可以往其中加入 Circle对象或者Circle 的子类对象， 但是不能加入 Shape 对象。 这里的原因在于列表 cicleSupers存储的元素类型为Cicle 的超类， 但是具体是 Cicle 的什么超类并不清楚。 但是我们可以确定的是只要是 Cicle 或者 Circle 的子类， 则一定是与该元素类别兼容。</div><div><br/></div><div><span style="font-weight: bold;">4、泛型方法</span></div><div><br/></div><div>泛型方法的格式， <span style="color: rgb(77, 206, 29);">类型参数&lt;T&gt;需要放在函数返回值之前</span>。 然后在参数和返回值中就可以使用泛型参数了。</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>01.public static &lt;T&gt; void fromArrayToCollection(T[] a, Collection&lt;T&gt;c){  </div><div>02.         for(T o : a) {</div><div>03.             c.add(o);<font color="#FF0000">// correct  </font></div><div>04.         }  </div><div>05. }</div></div><div><br/></div><div>调用方法如下：</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>01.Object[] oa = new Object[100];  </div><div>02.Collection&lt;Object&gt; co = new ArrayList&lt;Object&gt;();  </div><div>03.fromArrayToCollection(oa, co);// T inferred to be Object </div></div><div><br/></div><div>我们调用方法时并不需要传递类型参数,系统会自动判断类型参数并调用合适的方法。 当然</div><div>在某些情况下需要指定传递类型参数， 比如当存在与泛型方法相同的方法的时候（ 方法参数</div><div>类型不一致） ， 如下面的一个例子：</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>01. public &lt;T&gt; void go(T t) {  </div><div>02.     System.out.println(&quot;generic function&quot;);  </div><div>03. }  </div><div>04. public void go(String str) {  </div><div>05.     System.out.println(&quot;normal function&quot;);  </div><div>06. }  </div><div>07. public static void main(String[] args) {  </div><div>08.     FuncGenric fg = new FuncGenric();  </div><div>09.     fg.go(&quot;haha&quot;); <font color="#FF0000">//打印 normal function  </font></div><div>10.     fg.&lt;String&gt;go(&quot;haha&quot;); <font color="#FF0000">//打印 generic function  </font></div><div>11.     fg.go(new Object()); <font color="#FF0000">//打印 generic function  </font></div><div>12.     fg.&lt;Object&gt;go(new Object()); <font color="#FF0000">//打印 generic function  </font></div><div>13. }</div></div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">5、方法重载</span></div><div><br/></div><div><span style="color: rgb(77, 206, 29);">在 JAVA 里面方法重载是不能通过返回值类型来区分的，</span> 比如代码一中一个类中定义两个如</div><div>下的方法是不容许的。 但是当参数为泛型类型时， 却是可以的。 如下面代码所示， 虽然形参</div><div>经过类型擦除后都为 List 类型， 但是返回类型不同， 这是可以的。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>02. public class Erasure{  </div><div>03.    public void test(List&lt;String&gt; ls){  </div><div>04.       System.out.println(&quot;Sting&quot;);  </div><div>05.    }  </div><div>06.    public int test(List&lt;Integer&gt; li){  </div><div>07.       System.out.println(&quot;Integer&quot;);  </div><div>08.    }  </div><div>09. }</div></div><div><br/></div><div>  </div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">6、泛型数组</span></div><div><br/></div><div><span style="color: rgb(77, 206, 29);">不能创建一个确切泛型类型的数组</span>。 如下面代码会出错。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>List&lt;String&gt;[] lsa = new ArrayList&lt;String&gt;[10]; //compile error.</div></div><div>因为如果可以这样， 那么考虑如下代码， 会导致运行时错误。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><br/></div><div>01. List&lt;String&gt;[] lsa = new ArrayList&lt;String&gt;[10]; <font color="#FF0000">// 实际上并不允许这样创建数组</font>  </div><div>02. Object o = lsa;  </div><div>03. Object[] oa = (Object[]) o;  </div><div>04. List&lt;Integer&gt;li = new ArrayList&lt;Integer&gt;();  </div><div>05. li.add(new Integer(3));  </div><div>06. oa[1] = li;<font color="#FF0000">// unsound, but passes run time store check  </font></div><div>07. String s = lsa[1].get(0); <font color="#FF0000">//run-time error - ClassCastException</font></div></div><div><br/></div><div>因此<span style="color: rgb(77, 206, 29);">只能创建带通配符的泛型数组，</span> 如下面例子所示， 这回可以通过编译， 但是在倒数第二行代码中必须显式的转型才行， 即便如此， 最后还是会抛出类型转换异常， 因为存储在 lsa中的是 List&lt;Integer&gt;类型的对象， 而不是 List&lt;String&gt;类型。 最后一行代码是正确的， 类型匹配， 不会抛出异常。</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>01. List&lt;?&gt;[] lsa = new List&lt;?&gt;[10]; <font color="#FF0000">// ok, array of unbounded wildcard type  </font></div><div>02. Object o = lsa;  </div><div>03. Object[] oa = (Object[]) o;  </div><div>04. List&lt;Integer&gt;li = new ArrayList&lt;Integer&gt;();  </div><div>05. li.add(new Integer(3));  </div><div>06. oa[1] = li; <font color="#FF0000">//correct  </font></div><div>07. String s = (String) lsa[1].get(0);<font color="#FF0000">// run time error, but cast is explicit  </font></div><div>08. Integer it = (Integer)lsa[1].get(0); <font color="#FF0000">// OK</font></div></div><div><br/></div><div><span style="font-weight: bold;">7、不能抛出或捕获泛型类的实例</span></div><div><br/></div><div><span style="color: rgb(77, 206, 29);">既不能抛出也不能捕获泛型类对象， 甚至泛型类扩展 Throwable 都是不合法的。</span>如， 以下定义不能正常编译：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public class Problem&lt;T&gt; extends Exception{}//Error</div><div>    <font color="#FF0000">//catch 子句中不能使用类型变量， 以下方法不能编译：</font></div><div>    public static &lt;T extends Throwable&gt; void dowork(class&lt;T&gt; t){</div><div>           try {}catch(T e){} <font color="#FF0000">//error</font></div><div>    }</div><div><br/></div><div>    <font color="#FF0000"> //不过， 在异常规范中使用类型变量是允许的， 以下方法合法：</font></div><div>Public static &lt;T extends Throwable&gt; void doWork(T t) throws T{</div><div>           try{}Catch(Throwable realCause)</div><div>           {</div><div>             t.initCause(realCause);</div><div>             throw t;</div><div>           }</div><div>}</div></div><div><font style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">二、使用规范</span></font></div><div><br/></div><div><span style="color: rgb(255, 0, 0);">第23条：</span><span style="color: rgb(255, 0, 0);">不要在新代码中使用原生态类型</span></div><div><br/></div><div><br/></div><div>在1.5版本以后的代码建议使用泛型而不是对应的原生态类型，这有助于错误的发现，使用Java的特性，避免强制转换。是用原生态类型失去了泛型在安全性和表述性方面的所有优势。</div><div><br/></div><div>如果一些情况下客户代码不在乎类型参数T到底是什么的话，也建议使用泛型，如&lt;？&gt;，表示接受任何类型，相比于“T”限制了某一类型，“？”的范围过得多（？被成为无限制的通配符）。</div><div><br/></div><div>总之，使用原生态类型会在运行时导致异常，因此不要在新代码中使用。Set&lt;Object&gt;是个参数化类型，表示可以包含任何对象类型的一个集合；Set&lt;?&gt;则是一个通配符类型，表示只能包含某种未知对象类型的一个集合，Set则是原生态类型，他脱离了泛型系统。前两种是安全的，最后一中不安全。</div><div><br/></div><div><span style="color: rgb(255, 0, 0);">第24条：消除非受检警告</span></div><div><br/></div><div>在使用泛型时，会遇到许多编译器警告：非受检强制转化警告、非受检方法调用警告、非受检普通数组创建警告、以及非受检转换警告。</div><div><br/></div><div>如果无法消除警告，同时可以证明引起警告的代码是类型安全的，（只有在这种情况下）可以用一个<span style="color: rgb(77, 206, 29);">@SuppressWarnings（&quot;unchecked&quot;）</span>注解来禁止这条警告。</div><div><br/></div><div>SuppressWarnings注解可以用在任何粒度的级别中，从单独的局部变量声明到整个类都可以。应该始终在尽可能小的范围中使用SuppressWarnings注解。它通常是个变量声明，或是非常简短的方法或者构造器。永远不要再整个类上使用SuppressWarnings，那么做可能会掩盖了重要的警告。</div><div><br/></div><div><br/></div><div><span style="color: rgb(255, 0, 0);">第25条：</span><span style="color: rgb(255, 0, 0);">列表优先于数组</span></div><div><br/></div><div>数组和泛型的区别：</div><div><br/></div><div>（1）数组是协变的，即如果Sub为Super的子类型，那么数组类型Sub[]就是Super[]的子类型。相反，泛型则是不可变的，即对于任意两个不同的类型Type1和Type2，List&lt;Type1&gt;既不是List&lt;Type2&gt;的子类型，也不是List&lt;Type2&gt;的超类型。</div><div><br/></div><div>（2）数组是具体化的，因此数组会在运行时才知道并检查他们的元素类型约束。而泛型则是通过擦除实现的，因此<span style="font-weight: bold; font-style: italic; text-decoration: underline;">泛型只在编译时强化它们的类型信息，并在运行时丢弃（或擦除）它们的元素类型信息。</span></div><div><br/></div><div>由于数组和泛型之间的根本区别，数组和泛型不能很好的混合使用。创建泛型、参数化类型或者类型参数的数组都是非法的。如果混合使用出现了编译时错误或者警告，那么应该用列表代替数组</div><div><br/></div><div><span style="color: rgb(255, 0, 0);">第26条</span><span style="color: rgb(255, 0, 0);">：优先考虑泛型</span></div><div><br/></div><div>因为声明一个泛型数组是合法的，而new一个泛型数组是不合法的，那么当自定义一个泛型时，内部需要使用到泛型数组，如何new呢？</div><div><br/></div><div>一种方法是先new 一个Object数组，然后强制转换成对应的泛型的，编译器会警告这不是类型安全的，但我们在检查后确认无误，可以这样使用。</div><div><br/></div><div>例如：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>E[] elements = (E[])new Object[100];</div></div><div><br/></div><div><br/></div><div><br/></div><div>第二种方法是：将E[]改为Object[]，即</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>Object[] elements = new Object[100];</div></div><div>但是在获取对象后，要将对象强转为E即</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>E result = (E)elements[0];</div></div><div>这样做编译器会警告这是不安全的，可以通过</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>@SuppressWarnings（&quot;unchecked&quot;）</div></div><div>来解除警告。</div><div><br/></div><div><span style="color: rgb(255, 0, 0);">第27条：优先考虑泛型方法</span></div><div><br/></div><div>使用泛型方法可以不用在代码中显示进行类型转换，还可以进行类型推导。</div><div><br/></div><div>(1).编写一个集合并集的泛型方法：</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>01.public static &lt;E&gt; Set&lt;E&gt; union(Set&lt;E&gt; s1, Set&lt;E&gt; s2){    </div><div>02.    Set&lt;E&gt; result = new HashSet&lt;E&gt;(s1);    </div><div>03.    result.addAll(s2);     </div><div>04.    return result;    </div><div>05.}    </div></div><div><br/></div><div><br/></div><div>(2).泛型类型推导：</div><div><br/></div><div>正常声明泛型集合如下：</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>Map&lt;String, List&lt;String&gt;&gt;anagrams = new HashMap&lt;String, List&lt;String&gt;&gt;();</div></div><div><br/></div><div>通过集合声明时的泛型参数类型就可以推导出集合实例的泛型参数类型，这个过程叫泛型类型推导，如果支持泛型类型推导，则上面代码的HashMap就可以不再指定泛型参数类型，但是目前JDK还没有内置泛型类型推导，我们可以自己进行一个小的模拟实现：</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>01.public static &lt;K, V&gt; HashMap&lt;K, V&gt; newHashMap(){    </div><div>02.    return new HashMap&lt;K, V&gt;();    </div><div>03.}    </div><div>04.Map&lt;String, List&lt;String&gt;&gt; anagrams = newHashMap();    </div></div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">泛型单例工厂</span></div><div><br/></div><div>泛型单例工厂模式用于创建不可变但又适合于许多不同类型的对象，由于泛型是通过类型檫除实现的，因此可以给所有必要的类型参数使用单个对象，例子如下：</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>01.public interface UnaryFunction&lt;T&gt;{    </div><div>02.    T apply(T arg);    </div><div>03.}    </div><div>04.private static UnaryFunction&lt;Object&gt; IDENTITY_FUNCTION =     </div><div>05.new UnaryFunction&lt;Object&gt;(){    </div><div>06.    public Object apply(Object arg){    </div><div>07.    return arg;    </div><div>08.}    </div><div>09.}    </div><div>10.public static &lt;T&gt; UnaryFunction&lt;T&gt; identityFunction(){    </div><div>11.    return (UnaryFunction&lt;T&gt;) IDENTITY_FUNCTION;    </div><div>12.}    </div></div><div><br/></div><div><br/></div><div>由于泛型是类型檫除的，在运行时对于无状态的泛型参数类型只需要一个泛型单例即可。</div><div><br/></div><div>泛型递归类型限制</div><div><br/></div><div>使用泛型可以通过某个包含该类型参数本事的表达式来限制类型参数，如</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><br/></div><div>&lt;T extends Comparable&lt;T&gt;&gt;</div></div><div><br/></div><div>读作“针对可以与自身进行比较的每个类型T”,即互比性。</div><div><br/></div><div>下面的例子是找出列表中实现了Comparable接口的元素的最大值：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><br/></div><div>01.public static &lt;T extends Comparable&lt;T&gt;&gt; T max(List&lt;T&gt; list){    </div><div>02.    Iterator&lt;T&gt; i = list.iterator();    </div><div>03.    T result = i.next();    </div><div>04.    while(i.hasNext()){    </div><div>05.    T t = i.next();    </div><div>06.    if(<a href="http://t.compareto(result/">t.compareTo(result</a>) &gt; 0){    </div><div>07.    result = t;    </div><div>08.}    </div><div>09.return result;    </div><div>10.}    </div><div>11.}    </div></div><div><br/></div><div><br/></div><div><span style="color: rgb(255, 0, 0);">第28条：利用有限制通配符来提升API的灵活性</span></div><div><br/></div><div>由于泛型参数化类型是不可变的，对于任何类型的Type1和Type2而言，List&lt;Type1&gt;既不是List&lt;Type2&gt;的子类型，也不是它的超类型，由此会产生可以将任何对象放进List&lt;Object&gt;中，却只能将字符串放在List&lt;String&gt;中的问题，解决此类问题我们需要使用泛型的通配符。</div><div><br/></div><div>例子如下：</div><div><br/></div><div>自定义堆栈的API如下：</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>01.public class Stack&lt;E&gt; {    </div><div>02.    public Stack();    </div><div>03.    public void push(E e);    </div><div>04.    public E pop();    </div><div>05.    public boolean isEmpty();    </div><div>06.    public void pushAll(Iterable&lt;E&gt;  src){    </div><div>07.    for(E e : src){    </div><div>08.    push(e);    </div><div>09.}    </div><div>10.}    </div><div>11.    public void popAll(Collection&lt;E&gt; dst){    </div><div>12.    while(!isEmpty()){    </div><div>13.    dst.add(pop());    </div><div>14.}    </div><div>15.}    </div><div>16.}    </div></div><div><br/></div><div><br/></div><div>上述代码编译完全没有问题，但是如果想完美运行还需要使用泛型通配符。</div><div><br/></div><div>(1).生产者限制通配符extends：</div><div><br/></div><div>使用如下的测试数据对pushAll方法进行测试：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><br/></div><div>01.Stack&lt;Number&gt; numberStack = new Stack&lt;Number&gt;();    </div><div>02.Iterable&lt;Integer&gt; integers = …;    </div><div>03.numberStack.pushAll(integers);    </div></div><div><br/></div><div>在运行时pushAll方法会报参数类型不匹配错误，解决这个问题可以使用限制通配符类型，将pushAll方法修改如下：</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>01.public void pushAll(Iterable&lt;? extends E&gt;  src){    </div><div>02.    for(E e : src){    </div><div>03.    push(e);    </div><div>04.}    </div><div>05.}    </div></div><div><br/></div><div><br/></div><div>Iterable&lt;? extends E&gt;的意思是集合元素的类型是自身的子类型，即任何E的子类型，在本例子Integer是Number的子类，因此正好符合此意。</div><div><br/></div><div>(2).消费者限制通配符super：</div><div><br/></div><div>使用下面的测试数据对popAll方法进行测试:</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>01.Stack&lt;Integer&gt; integerStack = new Stack&lt; Integer&gt;();    </div><div>02.Iterable&lt;Number&gt; numbers = …;    </div><div>03.integerStack.popAll(numbers);    </div></div><div><br/></div><div>在运行时popAll方法会报参数类型不匹配错误，解决这个问题可以使用限制通配符类型，将popAll方法修改如下：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><br/></div><div>01.public void popAll(Collection&lt;? super E&gt; dst){    </div><div>02.    while(!isEmpty()){    </div><div>03.    dst.add(pop());    </div><div>04.}    </div><div>05.}    </div></div><div><br/></div><div><br/></div><div>Collection&lt;? super E&gt;的意思是集合元素的参数类型是自身的超类型，即任何E的超类，在本例中可以将Integer类型的元素添加到其超类Number的集合中。</div><div><br/></div><div>上述的两个通配符可以简记为PECS原则，即producer-extends,consumer-super.</div><div><br/></div><div>(3).无限制通配符?：</div><div><br/></div><div>对于同时具有生产者和消费者双重身份的对象来说，无限制通配符?更合适，一个交互集合元素的方法声明如下：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><br/></div><div>01.public static void swap(List&lt;?&gt; list, int i, list j);    </div></div><div><br/></div><div><br/></div><div>一般来说，如果类型参数只在方法声明中出现一次，就可以使用通配符取代它，如果是无限制的类型参数，就使用无限制通配符?代替。</div><div><br/></div><div>类型安全的异构容器</div><div><br/></div><div>第29条：优先考虑类型安全的异构容器</div><div><br/></div><div><br/></div><div>一般情况下，集合容器的只能由固定的类型参数，如一个Set只有一个类型参数表示它的类型，一个Map有两个类型参数表达键和值的类型，但是有些情况下我们需要更多的灵活性，即将容器的键进行参数化而不是将容器参数化，然后将参数化的键提交给容器，来插入或者获取值，用泛型系统来确保值的类型与它的键类型相符。</div><div><br/></div><div>在JDK1.5之后Class被泛化了，类的类型从字面上来看不再只是简单的Class，而是Class&lt;T&gt;，例如String.class属于Class&lt;String&gt;类型，Integer.class属于Class&lt;Integer&gt;类型。</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public class Favorites{</div><div>     private Map&lt;Class&lt;?&gt;, Object&gt; favorites = new HashMap&lt;Class&lt;?&gt;, Object&gt;();</div><div>     public &lt;T&gt; void putFavorites(Class&lt;T&gt; type, T instance){</div><div>         if(type == null){</div><div>            throws new NullPointerException(“Type is null”);</div><div>         }</div><div>         favorites.put(type, type.cast(instance));</div><div>     }</div><div>     public &lt;T&gt; T getFavorite(Class&lt;T&gt; type){</div><div>         return type.cast(favorites.get(type));</div><div>     }</div><div>     public static void main(String[] args){</div><div>         Favorites f = new Favorites();</div><div>         putFavorite(String.class, “java”);</div><div>         putFavorite(Integer.class, 0xcafebabe);</div><div>         putFavorite(Class.class, Favorite.class);</div><div>         String favoriteString = f.getFavorite(String.class);</div><div>         Int favoriteInteger = f.getFavorite(Integer.class);</div><div>         Class&lt;?&gt; favoritesClass = f.getFavorite(Class.class);</div><div>         System.out.printf(“%s %x %s%n”, favoriteString, favoriteInteger, favoritesClass);</div><div>     }</div><div>}</div></div><div><br/></div><div>程序正常打印出 <span style="color: rgb(255, 0, 0);">Java cafebabe Favorites。</span></div><div><br/></div></span>
</div></body></html> 
<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/306387 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="384"/>

<div>
<span><div><font style="font-size: 36pt;"><span style="font-size: 36pt; font-weight: bold;">关于servlet</span></font></div><div><span style="color: rgb(255, 70, 53);">一,什么是Servlet</span></div><div><br/></div><div>主要是要先讲明白Servlet是干嘛的.</div><div>Servlet是JavaWeb的 三大组件 之一,它属于动态资源,Servlet的作用是处理请求,服务器会把接收到的请求交给Servlet来处理,在Servlet中通常需要:</div><div>- 接收请求数据;</div><div>- 处理请求;</div><div>- 完成响应;</div><div><br/></div><div>例如客户端发出登录请求,或者输出注册请求,这些请求都应该由Servlet来完成处理!Servlet需要我们自己来编写,每个Servlet必须实现javax.servlet.Servlet接口.</div><div><br/></div><div><span style="color: rgb(255, 0, 0);">二,实现Servlet的方式</span></div><div><br/></div><div>实现Servlet的三种方式:(由我们来写)</div><div>- 实现javax.servlet.Servlet接口;</div><div>- 继承javax.servlet.GenericServlet类;</div><div>- 继承javax.servlet.http.HttpServlet类,会专门对http的请求提供一些支持;</div><div><br/></div><div>一般情况都是去继承HttpServlet类来完成Servlet(方便),但是学习Servlet的起始阶段,还要从javax.servlet.Servlet接口开始学习.</div><div><br/></div><div>服务器:相当于10086,Servlet就相当于10086中的话务员就等着人给打电话,服务器就是等着客户端来访问,根据访问的请求,将对应数据传递给客户端.</div><div>每个Servlet都是不同的,它们能处理的请求都是不同的.</div><div>Tomcat会将不同的请求,发送给对应的Servlet.</div><div>网络请求都是异步的.</div><div>注: Servlet中的生命周期等回调方法,都是服务器自动调用的.</div><div>注: Servlet的对象也是由服务器来创建.(比如Tomcat);</div><div><br/></div><div><span style="color: rgb(255, 0, 0);">三,如何让浏览器访问Servlet</span></div><div><br/></div><div>1,给Servlet指定一个Servlet路径,让Servlet与这个路径绑定在一起.</div><div>2,通过浏览器访问Servlet路径</div><div>3,需要在web.xml文件中对Servlet进行配置</div><div>&lt;servlet&gt;</div><div>  &lt;servlet-name&gt;名字&lt;/servlet-name&gt;</div><div>  &lt;servlet-class&gt;包名.Servlet类名&lt;/servlet-class&gt;</div><div>&lt;/servlet&gt;</div><div><br/></div><div>&lt;servlet-mapping&gt;</div><div>  &lt;!-- 此处名字与上一处相同 --&gt;</div><div>  &lt;servlet-name&gt;名字&lt;/servlet-name&gt;</div><div>  &lt;!-- .servlet扩展名可以不写,也可以直接写:XXXServlet --&gt;</div><div>  &lt;!-- 此处应该写的就是要在浏览器中输入的路径 --&gt;</div><div>  &lt;url-pattern&gt;/名字.servlet&lt;/url-pattern&gt;</div><div>&lt;/servlet-mapping&gt;</div><div><br/></div><div><span style="color: rgb(255, 0, 0);">四,生命周期方法</span></div><div>•void init(ServletConfig sc);//第一次被访问时会创建对象,创建对象后马上执行该方法</div><div>•void service(ServletRequest srq,SerletResponse srp);每次处理请求时都会执行该方法</div><div>•void destroy();即将销毁之前会执行该方法,一般为服务器被关闭之前会执行.</div><div><br/></div><div><span style="color: rgb(255, 0, 0);">五,特性</span></div><div>•每个Servlet类都是单例模式,但可以存在多个Servlet类.</div><div>•线程不安全,效率高.</div><div>•Servlet类由我们来写,对象由服务器创建,并且由服务器调用对应的方法.</div><div><br/></div><div><span style="color: rgb(255, 0, 0);">六,ServletConfig接口</span></div><div><br/></div><div>web.xml中的配置信息,会被加载进内存,在内存中以ServletConfig的实现类对象的形式存在.</div><div>所以如果想要获得Servlet的配置信息,可以直接通过ServletConfig的实现类对象来获得.</div><div>一个ServletConfig对象,对应一段web.xml中Servlet的配置信息.</div><div>方法介绍:</div><div>- String getServletName();获取的是中的内容;</div><div>- ServletContext getServletContext();获取Servlet上下文对象;</div><div>- String getInitParameter(String name);通过名称(key)获取指定初始化参数的值(value),初始化参数在web.xml中配置;</div><div>- Enumeration getInitParameterNames();获得所有初始化参数的名称,就是获取所有的key(在web.xml中配置);</div><div>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</div><div>&lt;web-app xmlns=&quot;<a href="http://xmlns.jcp.org/xml/ns/javaee">http://xmlns.jcp.org/xml/ns/javaee</a>&quot;</div><div>         xmlns:xsi=&quot;<a href="http://www.w3.org/2001/XMLSchema-instance">http://www.w3.org/2001/XMLSchema-instance</a>&quot;</div><div>         xsi:schemaLocation=&quot;<a href="http://xmlns.jcp.org/xml/ns/javaee">http://xmlns.jcp.org/xml/ns/javaee</a><a href="http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd">http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd</a>&quot;</div><div>         version=&quot;3.1&quot;&gt;</div><div><br/></div><div>    &lt;servlet&gt;</div><div>        &lt;servlet-name&gt;Servlet1&lt;/servlet-name&gt;</div><div>        &lt;servlet-class&gt;MyServlet&lt;/servlet-class&gt;</div><div>        &lt;!--初始化参数--&gt;</div><div>        &lt;init-param&gt;</div><div>            &lt;param-name&gt;k1&lt;/param-name&gt;</div><div>            &lt;param-value&gt;v1&lt;/param-value&gt;</div><div>        &lt;/init-param&gt;</div><div><br/></div><div>        &lt;init-param&gt;</div><div>            &lt;param-name&gt;k2&lt;/param-name&gt;</div><div>            &lt;param-value&gt;v2&lt;/param-value&gt;</div><div>        &lt;/init-param&gt;</div><div>    &lt;/servlet&gt;</div><div><br/></div><div>    &lt;servlet-mapping&gt;</div><div>        &lt;servlet-name&gt;Servlet1&lt;/servlet-name&gt;</div><div>        &lt;url-pattern&gt;/HelloServlet&lt;/url-pattern&gt;</div><div>    &lt;/servlet-mapping&gt;</div><div><br/></div><div><br/></div><div>&lt;/web-app&gt;</div><div><br/></div><div><span style="color: rgb(255, 0, 0);">七,GenericServlet抽象类</span></div><div><br/></div><div>该抽象类就是实现类部分Servlet接口的抽象方法,暴露出一个抽象方法Service();</div><div>很少会用.</div><div><br/></div><div>八,HttpServlet</div><div><br/></div><div>继承javax.servlet.http.HttpServlet类,会专门对http的请求提供一些支持;</div><div>能方便的获取请求方式(get或post等);</div><div>流程</div><div>// 使用方式:</div><div>// 1,在service生命周期中,将参数中的ServletRequest强转成HttpServletRequest,</div><div>// 将ServletResponse强转成HttpServletResponse.</div><div>// 2,在service生命周期中,调用非生命周期service方法,将强转后的参数传入</div><div>// 3,非生命周期的service方法,会根据传入的参数判断当前的请求方式(get或post)</div><div>// 4,如果为get,则会调用doGet方法,如果为post,则会调用doPost方法</div><div>// 5,所以我们需要复写doGet或doPost方法来做我们想做的事</div><div><br/></div><div>// 6,如果不覆盖doGet或doPost方法,访问时会405,服务器默认表示不支持该请求方式.</div><div>// 7,doGet和doPost不是抽象方法,有实体,实体就是给客户端返回一个405</div><div><br/></div><div><span style="color: rgb(255, 0, 0);">九,关于线程安全</span></div><div><br/></div><div>Servlet不是线程安全的,优势是效率高速度快.但是也存在线程安全问题,很可能出现多个线程同时对同一个对象进行读写操作.</div><div>注: 不要在Servlet中创建成员变量,创建局部变量即可.</div><div>注: 可以创建不存储数据的成员变量,该变量没有涉及到set/get等方法.</div><div>注: 可以创建存储数据的成员变量,但是该变量存储的数据必须是只读的.</div><div><br/></div><div>十,在web.xml中对Servlet配置,使得Servlet在服务器启动时就创建</div><div>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</div><div>&lt;web-app xmlns=&quot;<a href="http://xmlns.jcp.org/xml/ns/javaee">http://xmlns.jcp.org/xml/ns/javaee</a>&quot;</div><div>         xmlns:xsi=&quot;<a href="http://www.w3.org/2001/XMLSchema-instance">http://www.w3.org/2001/XMLSchema-instance</a>&quot;</div><div>         xsi:schemaLocation=&quot;<a href="http://xmlns.jcp.org/xml/ns/javaee">http://xmlns.jcp.org/xml/ns/javaee</a><a href="http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd">http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd</a>&quot;</div><div>         version=&quot;3.1&quot;&gt;</div><div><br/></div><div>    &lt;servlet&gt;</div><div>        &lt;servlet-name&gt;httpservlet&lt;/servlet-name&gt;</div><div>        &lt;servlet-class &gt;MyHttpServlet&lt;/servlet-class&gt;</div><div>        &lt;!-- 数值代表创建顺序 --&gt;</div><div>        &lt;load-on-startup&gt;0&lt;/load-on-startup&gt;</div><div>    &lt;/servlet&gt;</div><div><br/></div><div>    &lt;servlet-mapping&gt;</div><div>        &lt;servlet-name&gt;httpservlet&lt;/servlet-name&gt;</div><div>        &lt;url-pattern&gt;/wudi&lt;/url-pattern&gt;</div><div>    &lt;/servlet-mapping&gt;</div><div><br/></div><div><br/></div><div>&lt;/web-app&gt;</div><div><br/></div><div><span style="color: rgb(255, 0, 0);">十一,关于url-pattern&amp;</span></div><div><br/></div><div>标签是标签的子标签,用来定义浏览器访问Servlet时输入的url地址.</div><div>标签标签可以有多个,也就是可以输入多种url地址来访问同一个Servlet.</div><div>可以使用通配符*表示任意数量的任意字符</div><div>&lt;url-mapping&gt;</div><div>    &lt;servlet-name&gt;httpservlet&lt;/servlet-name&gt;</div><div>    &lt;url-pattern&gt;/wudi&lt;/url-pattern&gt;</div><div>    &lt;url-pattern&gt;/heheda&lt;/url-pattern&gt;</div><div>    &lt;!-- 路径匹配,就是只要路径对了就ok --&gt;</div><div>    &lt;url-pattern&gt;/heheda/*&lt;/url-pattern&gt;</div><div>    &lt;!-- 拓展名匹配,.do是Struts1推荐使用的,Struts2推荐使用.action --&gt;</div><div>    &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;</div><div>    &lt;!-- 匹配所有的url --&gt;</div><div>    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</div><div><br/></div><div>    &lt;!-- 如果上述匹配方式同时存在,则谁匹配的url越多,则谁优先级越低 --&gt;</div><div>    &lt;!-- 下面这种优先级最高 --&gt;</div><div>    &lt;url-pattern&gt;/heheda&lt;/url-pattern&gt;</div><div>&lt;/url-mapping&gt;</div><div><br/></div><div>注: 通配符*只能出现在两端,不能出现在url中间且只能存在一个通配符.</div><div><br/></div></span>
</div></body></html> 
XML(eXtended Markup Language,可扩展的标记语言) 提供一套跨平台、跨网络、跨程序
的语言的数据描述方式，使用XML可以方便的地实现数据交换、系统配置、内容管理等常见功能
  
   格式
   <?xml version="1.0" encoding="UTF-8"?>
<addresslist>
   <linkman>
       <name>李兴华</name>
	   <email>123@qq.com</email>
   </linkman>
   <linkman>
       <name>MLDN</name>
	   <email>456@qq.com</email>
   </linkman>
</addresslist>
  前导区：规定出XML页面的一些属性，其中有以下3个属性
    version:表示当前版本
	encoding: 表示当前编码
	standalone: 此XML文件是否独立运行如果需要进行显示可以使用CSS或XSL控制
	
	XML中的实体参照
	
	实体参照                对应字符
	&amp                    &
	&lt                     <
	&gt                     >
	&quot                   "
	&apos                   '
	<![CDATA[ 不解析内容]]> 
	
	XML解析
	
	DOM解析操作
	DOM的优势主要表现在：易用性强，使用DOM时，将把所有的XML文档信息都存于内存中，并且遍历简单，支持XPath，增强了易用性。
    DOM的缺点主要表现在：效率低，解析速度慢，内存占用量过高，对于大文件来说几乎不可能使用。另外效率低还表现在大量的消
	耗时间，因为使用DOM进行解析时，将为文档的每个element、attribute、processing-instrUCtion和comment都创建一个对象，这样
	在DOM机制中所运用的大量对象的创建和销毁无疑会影响其效率。
	DOM解析中的4个核心接口
	Document 接口中的常用方法
	方法                                                                                    描述
	public Node importNode(String tagname)throws DOMException                               取得指定节点名称的NodeList
	public Element createELement(String tagname) throws DOMException                        创建一个指定名称的节点
	public Text createTextNode(String data)                                                 创建一个内容节点
	public Element createElement(String tagName) throws DOMException                        创建一个节点元素
	public Attr createAttribute(String name) throws DOMException                            创建一个属性
	Node 接口中的常用方法
	方法                                                                                    描述
	public Node appendChild(Node newChild) throws DOMException                              在当前节点下增加一个新节点
	public NodeList getChildNodes()                                                         取得本节点的全部节点
	public Node getFirstChild()                                                             取得本节点的第一个节点 
	boolean hasChildNodes()                                                                 判断是否还有其他节点
	boolean hasAttributes()                                                                 判断是否还有其他属性
	tring getNodeValue()throws DOMException                                                 取得节点内容
	NodeList 接口中的常用方法
	方法                                                                                    描述
	public int getLength()                                                                  取得节点个数
	public Node item()                                                                      根据索引取得节点对象
	实例eg01.
	dom_demo_02.xml
	<?xml version="1.0" encoding="UTF-8"?>
    <addresslist>
    <name>李兴华</name>
    </addresslist>
	DOMDemo02.java
package DOM;
import java.io.IOException;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;
public class DOMDemo2 {
	public static void main (String[] args){
		//(1)建立DocumentBuilderFactory,以用于取得 DocumentBuilder
		DocumentBuilderFactory factor = DocumentBuilderFactory.newInstance();
		DocumentBuilder builder = null;
		try {
			builder = factor.newDocumentBuilder();
		} catch (ParserConfigurationException e) {
			e.printStackTrace();
		}
		//定义Document接口对象，通过Document 类进行DOM树的转换操作
		org.w3c.dom.Document doc = null;
		try {
			//读取指定路径的XML文件
			doc = builder.parse("d:/XMLText/dom_demo_02.xml");
		} catch (SAXException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
		//查找name的节点
		NodeList nl = doc.getElementsByTagName("name");
		System.out.println("姓名:"+nl.item(0).getFirstChild().getNodeValue());
	}
}
	运行结果
	姓名:李兴华
	
    将生成的XML文件输出到文件中——DOMDemo03.java
	package DOM;
import java.io.File;
import java.io.IOException;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
public class DOMDemo3 {
	public static void main (String[] args){
		DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
		DocumentBuilder builder = null;
		try {
			builder = factory.newDocumentBuilder();
		} catch (ParserConfigurationException e) {
			e.printStackTrace();
		}
		Document doc = null;
		doc = builder.newDocument();                                    //创建一个新的文档
		//建立个个操作点
		Element addresslist = doc.createElement("addresslist");         //建立节点
		Element linkman = doc.createElement("linkman");                 //
		Element name = doc.createElement("name");		                //
		Element email = doc.createElement("email");	                    //设置文本
		name.appendChild(doc.createTextNode("李兴华"));                  //
		linkman.appendChild(email);                                     //子节点
		email.appendChild(doc.createTextNode("799957684@qq.com"));       //
		linkman.appendChild(name);                                       //
		addresslist.appendChild(linkman);                                //
		doc.appendChild(addresslist);                                   //文档上保存节点
		//输出文档到文件点
		TransformerFactory tf = TransformerFactory.newInstance();
		Transformer t =null;
		try {
			t = tf.newTransformer();
		} catch (TransformerConfigurationException e) {
			e.printStackTrace();
		}
		t.setOutputProperty(OutputKeys.ENCODING,"GBK");                //设置编码
		DOMSource source = new DOMSource(doc);                         //输出文档
		StreamResult result = new StreamResult(new File("d:/XMLText/dom_demo_03.xml"));  //指定输出位置
		try {
			t.transform(source, result);                                 //输出
		} catch (TransformerException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
}
    运行结果
	<?xml version="1.0" encoding="GBK" standalone="no"?><addresslist><linkman><email>799957684@qq.com</email><name>李兴华</name></linkman></addresslist>
	生成的文件没有格式排列
	
	SAX解析操作
	SAX是一个解析速度快并且占用内存少的xml解析器，非常适合用于android等移动设备
	SAX全称是Simple API for Xml，既是指一种接口，也是一个软件包
	作为接口，sax是事件驱动型xml解析的一个标准接口
	Sax特点
	   1. 解析效率高，占用内存
	   2.可以随时停止解析
	   3.不能载入整个文档到内存
	   4.不能写入xml
	   5.SAX解析xml文件采用的是事件驱动
	   ---sax并不需要解析完 整个文档，在按内容顺序解析文档的过程中，sax会判断当前读到的字符是否合法xml语法中的某部分，如果符合就会触发事件
	Sax工作原理
	    Sax的工作原理简单的说，就是对文档进行顺序扫描，扫描到文档（document）开始与结束，扫描到元素（element）开始、结束等地方时调用事件处理
		处理函数做相应动作，然后继续扫描，直到文档结束。
		
		SAX主要事件
		方法                                                                                                描述
		public void startDocument() throws SAXException                                                     文档开始
		public void endDocument() throws SAXException                                                       文档结束
        public void startElement(String uri , String localName, String qName) throws SAXException		    元素开始，可以取得元素的名称及元素的全部属性
		public void startElement(String uri , String localName, String qName) throws SAXException           元素结束，可以取得元素的名称及元素的全部属性
		public void characters(char[] ,int start ,int length) throws SAXException                           元素内容
		
		编写SAX解析器——MySAX.java
		package SAX;
import org.xml.sax.Attributes;
import org.xml.sax.SAXException;
import org.xml.sax.helpers.DefaultHandler;
public class MySAX extends DefaultHandler{                 //定义SAX解析器
	@Override
	public void startDocument() throws SAXException {      //文档开始
		System.out.println("<?xml version=\"1.0\" encoding=\"GBK\"?>");
	}
	@Override
	public void endDocument() throws SAXException {
		System.out.println("\n文档读取结束");           //文档结束
 	}
	@Override
	public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {
		System.out.print("<");                       //元素开始
		System.out.print(qName);                  //输出元素名字
		if(attributes!=null){                        //取得全部属性
			for(int i=0;i<attributes.getLength();i++){
				System.out.print(" "+attributes.getQName(i)+"=\""+attributes.getValue(i)+"\"");
			}
		}
		System.out.println(">");
	}
	@Override
		public void characters(char[] ch, int start, int length) throws SAXException {   //取得元素内容
			// TODO Auto-generated method stub
			System.out.println(new String(ch,start,length));                                         //输出内容
		}
	@Override
		public void endElement(String uri, String localName, String qName) throws SAXException {    //元素结束
			System.out.print("<");
			System.out.print(qName);
			System.out.println("/>");
		}
}
         使用SAX解析器——TestSAX.java
		 package SAX;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;
import org.xml.sax.SAXException;
import org.xml.sax.helpers.DefaultHandler;
public class TestSAX {

	public static void main(String[] args) throws Exception, SAXException {
		//建立SAX解析工厂
		SAXParserFactory factory = SAXParserFactory.newInstance();
		//构造解析器
		SAXParser parser = factory.newSAXParser();
		//解析XML使用HANDER
		parser.parse("d:/XMLText/dom_demo_01.xml", new MySAX());
	}
}
        运行结果
<?xml version="1.0" encoding="GBK"?>
<addresslist>
<linkman>   
<name>
李兴华
<name/>   
<email>
123@qq.com
<email/>
<linkman/>
<linkman> 
<name>
MLDN
<name/>   
<email>
456@qq.com
<email/>
<linkman/>
<addresslist/>
文档读取结束

		
		